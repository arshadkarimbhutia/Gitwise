- **git version** : displays the installed Git version on the system; helps you verify if Git is installed.
- **git init** : initializes/creates a new Git repository. Make sure you are not already inside of a Git repository when you initialize one.
- **git status** : gives information on the current status of a Git repository.
- **git config --global user.name <!-- your name -->** : sets (if you provide a value after **user.name**) or displays (if you run it with no arguments) the global Git username.
- **git config --global user.email <!-- your email -->** : sets (if you provide a value after **user.email**) or displays (if you run it with no arguments) the global Git email address.
- **_git add_** : stages the changes for committing --- tells git to include updates to specific files, folders, etc. in the upcoming commit.
	- **git add <!-- filename(s) -->** : stages specific files for committing.
	- **git add .** : stages all changes in the current directory for committing. It does not stage the removal of files.
	- **git add -A** or **git add -all** : stages all changes in the current directory including new files, and removals. It's a more inclusive command than **git add .**
- **git commit** : commits/records the changes that you have staged using **_git add_** with a commit message. If you directly run this command it opens your default text editor for you to write a commit message (flexible for multi-line messages).
	- **git commit -m "<!-- commit message -->"** : commits changes in a concise way with a commit message directly from the command line.
	- **git commit --amend -m "<!-- commit message -->"** : modifies the last commit by allowing you to basically 'redo' the previous commit. It combines staged changes with the previous commit, effectively allowing you to add more changes or modify the commit message.
	- **git commit -a -m "<!-- commit message -->"** : commits all changes, including modifications and deletions for already tracked files, without the need for explicit **_git add_**. Note that it only skips the explicit **git add <!-- modified file(s) -->** for modified and deleted files. It won't handle new, untracked files---you still need to use **git add** for that.
- **git log** : displays the commit history of a Git repository by showing a chronological list of commits, starting from the most recent and going backward in time.
	- **git log --oneline** : displays each commit in a condensed, one-line format providing a concise overview of the commit history.
- **git branch** : lists all the existing branches in the repository. The branch with an asterisk is the currently active branch (the one you are currently on).
	- **git branch -v** : lists all the existing branches in the repository alongside the last commit on each branch with its commit message and hash.
	- **git branch -r** : lists all the existing remote branches our local repository knows about.
	- **git branch <!-- new branch name -->** : creates a new branch based upon the current HEAD. This just creates the branch---it does not switch you to that branch (the HEAD stays the same).
	- **git switch <!-- branch name -->/<!-- remote branch name -->** : switches to a specified existing branch in a Git repository by updating the HEAD pointer to point to the specified branch, effectively switching your working directory to the branch's latest commit. It is an alternative to the older **git checkout <!-- branch name -->** command. However, **git switch <!-- branch name -->** is a standalone switch command and much simpler because the latter does a million additional things. If you instead provide a remote branch name as argument, it will make a local branch of the same name and sets it up to track the remote branch then switches to the local branch it created. It then works as an alternative to the older **git checkout --track <!-- remote name -->/<!-- remote branch name -->** command.
	- **git switch -c <!-- new branch name -->** : creates a new branch and immediately switches to it---a concise way to perform the two-step process (of creating and switching to a branch) in a single one. It is an equivalent to the older **git checkout -b <!-- new branch name -->** command.
	- **git switch -** : switches back to the previously active branch. It is an equivalent to **git checkout -**.
	- **git branch -d <!-- branch name -->** or **git branch --delete <!-- branch name -->** :  deletes the specified branch if it is not currently checked-out. Note that if the branch has changes that are not yet merged into the current branch, Git will prevent you from deleting it using _-d_ or _--delete_. In such cases, you might need to force delete the branch using _-D_ or _--delete --force_. Also note that deleting a branch does not delete the commits; it only removes the branch reference.
	- **git branch -m <!-- new branch name -->** or **git branch --move <!-- new branch name -->** : renames the currently checked-out branch to a new name. Note that if you attempt to rename a branch to the same name it currently has, Git won't stop you, and the command will go through. However, the operation is essentially a no-op (it will result in no changes). Also note that if you attempt to rename a branch to a new name that already exists (as the name of some other branch), Git will prevent you from renaming it using _-m_ or _--move_. In such cases, you might need to force rename the branch using _-M_ or _--move --force_. This will overwrite any existing branch with the same name and the commit history of the branch you overwrite becomes part of the commit history of the newly named branch as its branch reference is lost.
- **git merge <!-- source branch name -->** : integrates changes from the specified source branch into the currently checked-out (destination/target) branch. In Git, this command fundamentally performs two types of merging:-
	1. Fast-Forward Merge: This occurs when the branch being merged into has no new commits since the branch being merged in. When you run the **git merge <!-- source branch name -->** command, it moves the branch pointer forward of the branch being merged into (target branch) to point the same commit as the branch being merged in (the specified source branch) without creating an extra merge commit. It essentially "fast-forwards" the branch pointer of the target branch to catch up on the commits of the source branch. This results in a linear commit history on the target branch which appears as a direct continuation of the changes made on the source branch.
	2. Three-Way (Regular) Merge/Creation of a Merge Commit: This occurs when there are divergent changes on both branches and the branch pointer can't be simply "fast-forwarded" i.e. the target branch and the source branch have both seen new commits since they diverged. When you run the **git merge <!-- source branch name -->** command you might as well run it with the _-m_ flag before mentioning the source branch name to enter a new commit message otherwise it will open your default text editor with a default message for you to do so: **git merge -m "<!-- commit message -->" <!-- source branch name -->**. This is because this type of merge involves creating a new merge commit that has two parent commits, indicating the point where the two branches were merged or integrated. One parent is the tip (latest commit) of the target branch and the other parent is that of the source branch. If there are conflicting changes (changes to the same lines of code in the same file, etc. on both branches), Git prompts you to resolve them manually, essentially leaving for you to decide which change will prevail over another.
- **git diff** : shows changes between different commits, branches, files, our working directory, and more. Without any additional options, the command compares the working directory and the staging area (index) and displays all the changes in our working directory that are not staged for the next commit. In other words, the differences are what you could tell Git to further add to the index but you still haven’t.
	- **git diff HEAD** :  compares the changes in your current working directory with the state of the repository at the latest commit (HEAD) and lists all changes made in the working tree since your last commit (HEAD). This includes both staged and unstaged changes.
	- **git diff --staged** or **git diff --cached** : compares the staging area (index) with your last commit (HEAD) and shows differences between them.
	- **git diff branch1..branch2** or **git diff branch1 branch2** : compares the tips of the two branches in the order specified and lists differences between them.
	- **git diff commit1..commit2** or **git diff commit1 commit2** : compares the two commits in the order specified and displays changes between them. Note that you provide commit hashes as arguments.
	> If you want to use the above diff commands with specific file(s) only, you can provide its/their filename(s) or path(s) after them:-
		- **git diff <!-- file1 file2 ... -->** or
		- **git diff HEAD <!-- file1 file2 ... -->** or
		- **git diff --staged <!-- file1 file2 ... -->** or
		- **git diff branch1..branch2 <!-- file1 file2 ... -->** or
		- **git diff commit1..commit2 <!-- file1 file2 ... -->**
- **git stash** : saves changes that you are not ready to commit yet. It essentially allows you to temporarily save your working directory and index allowing you to switch branches or perform other tasks without committing your changes. If you directly run this command or you run it with the _save_ argument: **git stash save**, it will take all uncommitted changes (staged or unstaged) and stash/save them, reverting the working directory and index to the state of the last commit. You can also include a stash message to describe the changes you're stashing by writing it within quotation marks after the stash command with the save option: **git stash save "<!-- stash message -->"**.
	- **git stash list** : displays a stash history of a Git repository by showing a chronological list of stashes, starting from the most recent and going backward in time.
	- **git stash apply** : applies the changes from the most recent stash to your working directory and index without removing the stash itself. This can be useful if you want to apply stashed changes to multiple branches.
	- **git stash drop** : drops or removes the most recent stash from the stash list permanently.
	- **git stash clear** : clears out the entire stash list permanently.
	- **git stash pop** : applies the most recent stash and removes it from the stash list. It's a combination of two different actions performed by two different commands:-
		1. Applying or restoring the most recent stash to your working directory and index. This action is performed by **git stash apply**.
		2. Dropping or removing the most recent or applied stash from the stash list. This action is typically performed by **git stash drop**.
	> The stash commands to apply, drop or pop stashes can be used with specific stashes only, too:-
		 1. **git stash apply stash@{<!-- stash index -->}** or
		 2. **git stash drop stash@{<!-- stash index -->}** or
		 3. **git stash pop stash@{<!-- stash index -->}**
- 